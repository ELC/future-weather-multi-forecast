<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Forecast Dashboard</title>
    <style>
        /* ========================================
           CSS - BEM Methodology
           ======================================== */
        
        :root {
            --color-primary: #4a90e2;
            --color-secondary: #50c878;
            --color-background: #f5f7fa;
            --color-surface: #ffffff;
            --color-text: #333333;
            --color-text-light: #666666;
            --color-error: #e74c3c;
            --color-border: #e0e0e0;
            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --border-radius: 8px;
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--color-background);
            color: var(--color-text);
            line-height: 1.6;
        }

        /* Dashboard Block */
        .dashboard {
            max-width: 1200px;
            margin: 0 auto;
            padding: var(--spacing-lg);
        }

        .dashboard__header {
            text-align: center;
            margin-bottom: var(--spacing-lg);
        }

        .dashboard__title {
            font-size: 2.5rem;
            color: var(--color-primary);
            margin-bottom: var(--spacing-xs);
        }

        .dashboard__subtitle {
            color: var(--color-text-light);
            font-size: 1rem;
        }

        /* Form Block */
        .forecast-form {
            background: var(--color-surface);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            margin-bottom: var(--spacing-lg);
        }

        .forecast-form__group {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-sm);
            align-items: flex-end;
        }

        .forecast-form__field {
            flex: 1;
            min-width: 200px;
        }

        .forecast-form__label {
            display: block;
            margin-bottom: var(--spacing-xs);
            font-weight: 500;
            color: var(--color-text);
        }

        .forecast-form__input {
            width: 100%;
            padding: var(--spacing-sm);
            border: 1px solid var(--color-border);
            border-radius: var(--border-radius);
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        .forecast-form__input:focus {
            outline: none;
            border-color: var(--color-primary);
        }

        .forecast-form__button {
            padding: var(--spacing-sm) var(--spacing-lg);
            background-color: var(--color-primary);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
        }

        .forecast-form__button:hover {
            background-color: #3a7bc8;
        }

        .forecast-form__button:active {
            transform: scale(0.98);
        }

        .forecast-form__button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        /* Status Block */
        .status {
            margin-bottom: var(--spacing-md);
            padding: var(--spacing-sm);
            border-radius: var(--border-radius);
            text-align: center;
        }

        .status--loading {
            background-color: #fff3cd;
            color: #856404;
        }

        .status--error {
            background-color: #f8d7da;
            color: var(--color-error);
        }

        .status--hidden {
            display: none;
        }

        /* Forecast Block */
        .forecast {
            background: var(--color-surface);
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
        }

        .forecast--hidden {
            display: none;
        }

        .forecast__header {
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-sm);
            border-bottom: 2px solid var(--color-border);
        }

        .forecast__location {
            font-size: 1.5rem;
            color: var(--color-text);
            margin-bottom: var(--spacing-xs);
        }

        .forecast__date {
            color: var(--color-text-light);
            font-size: 0.9rem;
        }

        .forecast__services {
            display: grid;
            gap: var(--spacing-md);
        }

        /* Weather Card Block */
        .weather-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: var(--spacing-md);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
        }

        .weather-card:nth-child(2) {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .weather-card:nth-child(3) {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .weather-card__header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
        }

        .weather-card__service {
            font-size: 0.9rem;
            opacity: 0.9;
            font-weight: 500;
        }

        .weather-card__status {
            font-size: 0.85rem;
            padding: 0.25rem 0.5rem;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        .weather-card__main {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
        }

        .weather-card__temperature {
            font-size: 3rem;
            font-weight: 300;
        }

        .weather-card__condition {
            text-align: right;
        }

        .weather-card__description {
            font-size: 1.2rem;
            margin-bottom: var(--spacing-xs);
        }

        .weather-card__icon {
            font-size: 2rem;
        }

        .weather-card__details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: var(--spacing-sm);
            padding-top: var(--spacing-sm);
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        .weather-card__detail {
            display: flex;
            flex-direction: column;
        }

        .weather-card__detail-label {
            font-size: 0.85rem;
            opacity: 0.8;
            margin-bottom: 0.25rem;
        }

        .weather-card__detail-value {
            font-size: 1.1rem;
            font-weight: 500;
        }

        .weather-card__error {
            opacity: 0.8;
            margin-top: 1rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .dashboard {
                padding: var(--spacing-sm);
            }

            .dashboard__title {
                font-size: 2rem;
            }

            .forecast-form__group {
                flex-direction: column;
            }

            .forecast-form__field {
                width: 100%;
            }

            .weather-card__main {
                flex-direction: column;
                text-align: center;
            }

            .weather-card__condition {
                text-align: center;
                margin-top: var(--spacing-sm);
            }
        }
    </style>
</head>
<body>
    <!-- Main Dashboard -->
    <main class="dashboard">
        <!-- Dashboard Header -->
        <header class="dashboard__header">
            <h1 class="dashboard__title">Weather Forecast Dashboard</h1>
            <p class="dashboard__subtitle">Get weather forecasts from multiple sources</p>
        </header>

        <!-- Forecast Form -->
        <section class="forecast-form">
            <form class="forecast-form__group" id="forecastForm">
                <div class="forecast-form__field">
                    <label for="dateInput" class="forecast-form__label">Select Date</label>
                    <input 
                        type="date" 
                        id="dateInput" 
                        class="forecast-form__input" 
                        required
                    >
                </div>
                <div class="forecast-form__field">
                    <label for="cityInput" class="forecast-form__label">City</label>
                    <input 
                        type="text" 
                        id="cityInput" 
                        class="forecast-form__input" 
                        placeholder="e.g., New York, Paris, Tokyo"
                        required
                    >
                </div>
                <button id="submitButton" type="submit" class="forecast-form__button">Get Forecast</button>
            </form>
        </section>

        <!-- Status Messages -->
        <aside class="status status--hidden" id="statusMessage" role="status" aria-live="polite"></aside>

        <!-- Forecast Results -->
        <section class="forecast forecast--hidden" id="forecastResults">
            <header class="forecast__header">
                <h2 class="forecast__location" id="forecastLocation">Location</h2>
                <p class="forecast__date" id="forecastDate">Date</p>
            </header>
            <div class="forecast__services" id="forecastServices">
                <!-- Weather cards will be inserted here -->
            </div>
        </section>
    </main>

    <script>
        // ========================================
        // Configuration
        // ========================================

        /**
         * Application configuration constants
         * @type {Object}
         */
        const CONFIG = {
            DEFAULT_LOCATION: {
                city: 'New York'
            },
            OPEN_METEO: {
                API_URL: 'https://api.open-meteo.com/v1/forecast',
                DAILY_PARAMS: ['temperature_2m_max', 'temperature_2m_min', 'weathercode', 'precipitation_sum', 'windspeed_10m_max']
            },
            GEOCODING: {
                API_URL: 'https://nominatim.openstreetmap.org/search',
                FORMAT: 'json',
                LIMIT: 1
            },
            VALIDATION: {
                LATITUDE_MIN: -90,
                LATITUDE_MAX: 90,
                LONGITUDE_MIN: -180,
                LONGITUDE_MAX: 180
            },
            FORMATTING: {
                COORDINATE_DECIMALS: 4,
                TEMPERATURE_DECIMALS: 1
            }
        };

        // ========================================
        // Utility Functions
        // ========================================

        /**
         * Temperature conversion utilities
         * @type {Object}
         */
        const TemperatureUtils = {
            /**
             * Converts Celsius to Fahrenheit
             * @param {number} celsius - Temperature in Celsius
             * @returns {number} Temperature in Fahrenheit
             */
            celsiusToFahrenheit: (celsius) => (celsius * 9/5 + 32),

            /**
             * Rounds a number to specified decimal places
             * @param {number} value - Value to round
             * @param {number} decimals - Number of decimal places
             * @returns {number} Rounded value
             */
            roundToDecimal: (value, decimals = CONFIG.FORMATTING.TEMPERATURE_DECIMALS) => {
                const factor = Math.pow(10, decimals);
                return Math.round(value * factor) / factor;
            }
        };

        /**
         * Coordinate formatting utilities
         * @type {Object}
         */
        const CoordinateUtils = {
            /**
             * Formats coordinates with proper directional indicators
             * @param {Coordinates} coordinates - Latitude and longitude
             * @param {number} decimals - Number of decimal places
             * @returns {string} Formatted coordinate string
             */
            format: ({ latitude, longitude }, decimals = CONFIG.FORMATTING.COORDINATE_DECIMALS) => {
                const latDir = latitude >= 0 ? 'N' : 'S';
                const lonDir = longitude >= 0 ? 'E' : 'W';
                return `${Math.abs(latitude).toFixed(decimals)}Â°${latDir}, ${Math.abs(longitude).toFixed(decimals)}Â°${lonDir}`;
            }
        };


        // ========================================
        // Type Definitions
        // ========================================

        // --- Core Data Types ---

        /**
         * @typedef {Object} Coordinates
         * @property {number} latitude - Latitude coordinate
         * @property {number} longitude - Longitude coordinate
         */

        /**
         * @typedef {Object} ForecastRequest
         * @property {string} date - ISO date string (YYYY-MM-DD)
         * @property {Coordinates} coordinates - Location coordinates
         * @property {string} [displayName] - Full display name from geocoding service
         */

        /**
         * @typedef {{data: ForecastRequest} | {error: string}} ForecastRequestResult
         * Result of forecast request validation - either valid data or error message
         */

        /**
         * @typedef {Object} WeatherData
         * @property {number} temperature - Temperature in Celsius
         * @property {number} temperatureFahrenheit - Temperature in Fahrenheit
         * @property {string} description - Weather condition description
         * @property {number} humidity - Humidity percentage
         * @property {number} windSpeed - Wind speed in km/h
         * @property {number} precipitation - Precipitation in mm
         * @property {string} icon - Weather icon representation
         */

        // --- Weather Provider Types ---

        /**
         * @typedef {{serviceName: string, data: WeatherData} | {serviceName: string, error: string}} ForecastResult
         * Forecast result from a provider - success case has data, error case has error message
         */

        /**
         * @typedef {Object} WeatherProvider
         * @property {string} name - Name of the weather service
         * @property {(request: ForecastRequest) => Promise<ForecastResult>} fetchForecast - Fetches forecast for given request
         */

        /**
         * @typedef {Object} WeatherService
         * @property {(request: ForecastRequest) => Promise<Array<ForecastResult>>} forecast - Fetches forecasts from all providers
         */

        // --- Open-Meteo API Types ---

        /**
         * @typedef {Object} OpenMeteoDailyData
         * @property {Array<number>} temperature_2m_max - Maximum temperatures in Celsius
         * @property {Array<number>} temperature_2m_min - Minimum temperatures in Celsius
         * @property {Array<number>} weathercode - WMO weather codes
         * @property {Array<number>} windspeed_10m_max - Maximum wind speeds in km/h
         * @property {Array<number>} precipitation_sum - Precipitation sums in mm
         */

        /**
         * @typedef {Object} OpenMeteoApiResponse
         * @property {OpenMeteoDailyData} daily - Daily weather data
         * @property {Array<string>} [time] - Time array for the daily data
         */

        /**
         * @typedef {{data: OpenMeteoApiResponse} | {error: string}} OpenMeteoJsonResult
         * Result of JSON fetch and parse operation for Open-Meteo API
         */

        /**
         * @typedef {{data: OpenMeteoDailyData} | {error: string}} OpenMeteoValidationResult
         * Result of Open-Meteo validation - either daily weather data or error
         */

        // --- Wttr.in API Types ---

        /**
         * @typedef {Object} WttrinWeatherDescription
         * @property {string} value - Weather description text
         */

        /**
         * @typedef {Object} WttrinHourlyData
         * @property {string} windspeedKmph - Wind speed in km/h as string
         * @property {string} precipMM - Precipitation in mm as string
         * @property {string} humidity - Humidity percentage as string
         * @property {Array<WttrinWeatherDescription>} weatherDesc - Array of weather descriptions
         */

        /**
         * @typedef {Object} WttrinDailyWeather
         * @property {string} [avgtempC] - Average temperature in Celsius as string
         * @property {string} [maxtempC] - Maximum temperature in Celsius as string
         * @property {string} [mintempC] - Minimum temperature in Celsius as string
         * @property {Array<WttrinHourlyData>} [hourly] - Hourly weather data array
         */

        /**
         * @typedef {Object} WttrinApiResponse
         * @property {Array<WttrinDailyWeather>} weather - Array of daily weather data
         */

        /**
         * @typedef {{data: WttrinApiResponse} | {error: string}} WttrinJsonResult
         * Result of JSON fetch and parse operation for wttr.in API
         */

        /**
         * @typedef {{data: WttrinDailyWeather} | {error: string}} WttrinValidationResult
         * Result of wttr.in validation - either a single day's weather data or error
         */

        // --- Geocoding API Types ---

        /**
         * @typedef {Object} NominatimLocation
         * @property {string} lat - Latitude as string
         * @property {string} lon - Longitude as string
         * @property {string} display_name - Full display name of the location
         * @property {string} [place_id] - Unique place identifier
         * @property {string} [type] - Type of location (city, town, etc.)
         */

        /**
         * @typedef {Array<NominatimLocation>} NominatimApiResponse
         * Array of location results from Nominatim API
         */

        /**
         * @typedef {{data: NominatimApiResponse} | {error: string}} GeocodingFetchResult
         * Result of geocoding API fetch and parse operation
         */

        /**
         * @typedef {{data: NominatimLocation} | {error: string}} GeocodingValidationResult
         * Result of geocoding validation - either a single location or error
         */

        /**
         * @typedef {Object} CoordinateData
         * @property {number} latitude - Latitude coordinate
         * @property {number} longitude - Longitude coordinate
         * @property {string} displayName - Full display name of the location
         */

        /**
         * @typedef {{data: CoordinateData} | {error: string}} GeocodingResult
         * Result of geocoding operation - either coordinate data or error message
         */

        /**
         * @typedef {Object} GeocodingService
         * @property {string} name - Name of the geocoding service
         * @property {(cityName: string) => Promise<GeocodingResult>} geocode - Converts city name to coordinates
         */

        // --- Constants Types ---

        /**
         * @typedef {Object.<number, string>} WeatherDescriptionMap
         * Mapping of WMO weather codes to their descriptions
         */

        /**
         * @typedef {Object} WeatherIconMapping
         * @property {number} max - Maximum weather code for this icon
         * @property {string} icon - Weather icon emoji
         */

        // --- Component Types ---

        /**
         * @typedef {Object} StatusMessage
         * @property {(message: string, type: 'loading'|'error') => void} show - Shows status message
         * @property {() => void} hide - Hides status message
         */

        /**
         * @typedef {Object} ForecastFormComponent
         * @property {() => Promise<ForecastRequestResult>} createRequest - Creates and validates forecast request (async for geocoding)
         * @property {() => void} setDefaultValues - Sets default form values
         * @property {() => void} disable - Disables form submission
         * @property {() => void} enable - Enables form submission
         * @property {(callback: () => Promise<void>) => void} onSubmit - Registers form submit handler
         */

        /**
         * @typedef {Object} ForecastResultComponent
         * @property {() => void} show - Shows forecast section
         * @property {() => void} hide - Hides forecast section
         * @property {(request: ForecastRequest) => void} displayInfo - Displays forecast location and date
         * @property {(results: Array<ForecastResult>) => void} displayResults - Displays weather results
         */

        /**
         * @typedef {Object} AppStateComponents
         * @property {ForecastFormComponent} forecastForm - Forecast form component
         * @property {StatusMessage} statusMessage - Status message component
         * @property {ForecastResultComponent} forecastResult - Forecast result component
         * @property {WeatherService} weatherService - Weather service
         */

        /**
         * @typedef {Object} AppState
         * @property {() => void} setDefaultValues - Sets default values for all components
         * @property {() => void} initialize - Initializes the application
         * @property {() => Promise<void>} update - Updates forecast with registered weather service
         */

        // ========================================
        // Constants
        // ========================================

        /**
         * WMO Weather code descriptions mapping
         * @type {WeatherDescriptionMap}
         */
        const WMO_WEATHER_DESCRIPTIONS = {
            0: 'Clear sky',
            1: 'Mainly clear',
            2: 'Partly cloudy',
            3: 'Overcast',
            45: 'Foggy',
            48: 'Depositing rime fog',
            51: 'Light drizzle',
            53: 'Moderate drizzle',
            55: 'Dense drizzle',
            61: 'Slight rain',
            63: 'Moderate rain',
            65: 'Heavy rain',
            71: 'Slight snow',
            73: 'Moderate snow',
            75: 'Heavy snow',
            77: 'Snow grains',
            80: 'Slight rain showers',
            81: 'Moderate rain showers',
            82: 'Violent rain showers',
            85: 'Slight snow showers',
            86: 'Heavy snow showers',
            95: 'Thunderstorm',
            96: 'Thunderstorm with slight hail',
            99: 'Thunderstorm with heavy hail'
        };

        /**
         * WMO Weather code to icon mapping ranges
         * @type {Array<WeatherIconMapping>}
         */
        const WMO_WEATHER_ICONS = [
            { max: 0, icon: 'â˜€ï¸' },
            { max: 3, icon: 'â›…' },
            { max: 48, icon: 'ðŸŒ«ï¸' },
            { max: 55, icon: 'ðŸŒ¦ï¸' },
            { max: 65, icon: 'ðŸŒ§ï¸' },
            { max: 77, icon: 'â„ï¸' },
            { max: 82, icon: 'ðŸŒ§ï¸' },
            { max: 86, icon: 'ðŸŒ¨ï¸' },
            { max: Infinity, icon: 'â›ˆï¸' }
        ];

        // ========================================
        // Business Logic - Geocoding Service
        // ========================================

        /**
         * Creates a geocoding service for converting city names to coordinates
         * @returns {GeocodingService} Geocoding service implementation
         */
        const createGeocodingService = () => {
            const name = 'OpenStreetMap Nominatim';

            /**
             * Builds geocoding API URL
             * @param {string} cityName - Name of the city
             * @returns {string} API URL
             */
            const buildApiUrl = (cityName) => {
                const url = new URL(CONFIG.GEOCODING.API_URL);
                url.searchParams.append('q', cityName.trim());
                url.searchParams.append('format', CONFIG.GEOCODING.FORMAT);
                url.searchParams.append('limit', CONFIG.GEOCODING.LIMIT.toString());
                return url.toString();
            };

            /**
             * Fetches and parses geocoding results
             * @param {string} url - API URL
             * @returns {Promise<GeocodingFetchResult>} Parsed results or error
             */
            const fetchAndParseResults = async (url) => {
                const response = await fetch(url).catch(() => null);

                if (!response) {
                    return { error: 'Network error occurred' };
                }

                if (!response.ok) {
                    return { error: `Geocoding failed with status: ${response.status}` };
                }

                const results = await response.json().catch(() => null);

                if (!results) {
                    return { error: 'Failed to parse geocoding response' };
                }

                return { data: results };
            };

            /**
             * Validates geocoding results
             * @param {GeocodingFetchResult} fetchResult - Fetch result from API
             * @param {string} cityName - Original city name
             * @returns {GeocodingValidationResult} Validation result
             */
            const validateResults = (fetchResult, cityName) => {
                if ('error' in fetchResult) {
                    return { error: fetchResult.error };
                }

                if (!fetchResult.data || fetchResult.data.length === 0) {
                    return { error: `City "${cityName}" not found. Please try a different name or be more specific.` };
                }
                
                return { data: fetchResult.data[0] };
            };

            /**
             * Transforms geocoding result to coordinate data
             * @param {GeocodingValidationResult} validationResult - Validation result
             * @returns {GeocodingResult} Transformed coordinates
             */
            const transformLocationData = (validationResult) => {
                if ('error' in validationResult) {
                    return { error: validationResult.error };
                }

                const location = validationResult.data;
                return {
                    data: {
                        latitude: parseFloat(location.lat),
                        longitude: parseFloat(location.lon),
                        displayName: location.display_name
                    }
                };
            };

            return {
                name,
                /**
                 * Converts a city name to latitude and longitude coordinates
                 * @param {string} cityName - Name of the city
                 * @returns {Promise<GeocodingResult>} Coordinates or error
                 */
                geocode: async (cityName) => {
                    const url = buildApiUrl(cityName);
                    const fetchResult = await fetchAndParseResults(url);
                    const validationResult = validateResults(fetchResult, cityName);
                    return transformLocationData(validationResult);
                }
            };
        };

        // ========================================
        // Business Logic - Weather Services
        // ========================================

        /**
         * Creates a weather service for Open-Meteo API
         * @returns {WeatherProvider} Weather provider implementation
         */
        const createOpenMeteoService = () => {
            const name = 'Open-Meteo';

            /**
             * Maps WMO weather codes to icons
             * @param {number} code - WMO weather code
             * @returns {string} Weather icon
             */
            const getWeatherIcon = (code) => {
                const iconMapping = WMO_WEATHER_ICONS.find(mapping => code <= mapping.max);
                return iconMapping ? iconMapping.icon : 'â“';
            };

            /**
             * Transforms validation result to ForecastResult
             * @param {OpenMeteoValidationResult} validationResult - Validation result from API response
             * @returns {ForecastResult} Complete forecast result with service name
             */
            const transformOpenMeteoData = (validationResult) => {
                if ('error' in validationResult) {
                    return {
                        serviceName: name,
                        error: validationResult.error
                    };
                }
                
                const daily = validationResult.data;
                const tempMax = daily.temperature_2m_max[0];
                const tempMin = daily.temperature_2m_min[0];
                const avgTemp = (tempMax + tempMin) / 2;
                const weatherCode = daily.weathercode[0];
                
                return {
                    serviceName: name,
                    data: {
                        temperature: TemperatureUtils.roundToDecimal(avgTemp),
                        temperatureFahrenheit: TemperatureUtils.roundToDecimal(TemperatureUtils.celsiusToFahrenheit(avgTemp)),
                        description: WMO_WEATHER_DESCRIPTIONS[weatherCode] || 'Unknown',
                        humidity: 0,
                        windSpeed: TemperatureUtils.roundToDecimal(daily.windspeed_10m_max[0]),
                        precipitation: TemperatureUtils.roundToDecimal(daily.precipitation_sum[0]),
                        icon: getWeatherIcon(weatherCode)
                    }
                };
            };

            /**
             * Builds API URL for weather request
             * @param {string} date - Date string
             * @param {number} latitude - Latitude coordinate
             * @param {number} longitude - Longitude coordinate
             * @returns {string} API URL
             */
            const buildApiUrl = (date, latitude, longitude) => {
                const url = new URL(CONFIG.OPEN_METEO.API_URL);
                const params = {
                    latitude: latitude.toString(),
                    longitude: longitude.toString(),
                    daily: CONFIG.OPEN_METEO.DAILY_PARAMS.join(','),
                    timezone: 'auto',
                    start_date: date,
                    end_date: date
                };
                Object.entries(params).forEach(([key, value]) => url.searchParams.append(key, value));
                return url.toString();
            };

            /**
             * Fetches and parses JSON from API
             * @param {string} url - API URL
             * @returns {Promise<OpenMeteoJsonResult>} Parsed JSON result or error
             */
            const fetchAndParseJson = async (url) => {
                const response = await fetch(url).catch(() => null);
                
                if (!response) {
                    return { error: 'Network error occurred' };
                }
                
                if (!response.ok) {
                    return { error: `HTTP error! status: ${response.status}` };
                }
                
                const json = await response.json().catch(() => null);
                
                if (!json) {
                    return { error: 'Failed to parse response' };
                }
                
                return { data: json };
            };

            /**
             * Validates API response data
             * @param {OpenMeteoJsonResult} json - Parsed JSON from Open-Meteo API
             * @returns {OpenMeteoValidationResult} Validation result
             */
            const validateResponseData = (json) => {
                if ("error" in json && json.error) {
                    return { error: json.error };
                }
                
                if (!("data" in json) || !("daily" in json.data) || !("time" in json.data.daily) || json.data.daily.time.length === 0) {
                    return { error: 'No data available for the selected date' };
                }
                
                return { data: json.data.daily };
            };

            return {
                name,
                /**
                 * Fetches forecast from Open-Meteo API
                 * @param {ForecastRequest} request - Forecast request parameters
                 * @returns {Promise<ForecastResult>} Forecast result
                 */
                fetchForecast: async ({ date, coordinates: { latitude, longitude } }) => {
                    const url = buildApiUrl(date, latitude, longitude);
                    const jsonResult = await fetchAndParseJson(url);
                    const validationResult = validateResponseData(jsonResult);
                    return transformOpenMeteoData(validationResult);
                }
            };
        };

        /**
         * Creates a weather service for wttr.in API
         * @returns {WeatherProvider} Weather provider implementation
         */
        const createWttrinService = () => {
            const name = 'Wttr.in';

            /**
             * Maps weather description to appropriate icon
             * @param {string} description - Weather description from API
             * @returns {string} Weather icon
             */
            const getWeatherIcon = (description) => {
                const desc = description.toLowerCase();
                if (desc.includes('clear') || desc.includes('sunny')) return 'â˜€ï¸';
                if (desc.includes('partly cloudy') || desc.includes('partly')) return 'â›…';
                if (desc.includes('cloudy') || desc.includes('overcast')) return 'â˜ï¸';
                if (desc.includes('fog') || desc.includes('mist')) return 'ðŸŒ«ï¸';
                if (desc.includes('drizzle')) return 'ðŸŒ¦ï¸';
                if (desc.includes('rain') || desc.includes('shower')) return 'ðŸŒ§ï¸';
                if (desc.includes('snow') || desc.includes('sleet')) return 'â„ï¸';
                if (desc.includes('thunder') || desc.includes('storm')) return 'â›ˆï¸';
                return 'ðŸŒ¤ï¸';
            };

            /**
             * Builds API URL for weather request
             * @param {number} latitude - Latitude coordinate
             * @param {number} longitude - Longitude coordinate
             * @param {string} date - Date string (YYYY-MM-DD)
             * @returns {string} API URL
             */
            const buildApiUrl = (latitude, longitude, date) => {
                // wttr.in supports format like: wttr.in/lat,lon?format=j1&date=YYYY-MM-DD
                return `https://wttr.in/${latitude},${longitude}?format=j1&date=${date}`;
            };

            /**
             * Fetches and parses JSON from API
             * @param {string} url - API URL
             * @returns {Promise<WttrinJsonResult>} Parsed JSON result or error
             */
            const fetchAndParseJson = async (url) => {
                const response = await fetch(url).catch(() => null);
                
                if (!response) {
                    return { error: 'Network error occurred' };
                }
                
                if (!response.ok) {
                    return { error: `HTTP error! status: ${response.status}` };
                }
                
                const json = await response.json().catch(() => null);
                
                if (!json) {
                    return { error: 'Failed to parse response' };
                }
                
                return { data: json };
            };

            /**
             * Validates and extracts weather data from API response
             * @param {WttrinJsonResult} json - Parsed JSON from wttr.in API
             * @returns {WttrinValidationResult} Validation result
             */
            const validateResponseData = (json) => {
                if ("error" in json && json.error) {
                    return { error: json.error };
                }
                
                if (!("data" in json) || !("weather" in json.data) || !json.data.weather || json.data.weather.length === 0) {
                    return { error: 'No data available for the selected date' };
                }
                
                return { data: json.data.weather[0] };
            };

            /**
             * Transforms wttr.in data to WeatherData format
             * @param {WttrinValidationResult} validationResult - Validation result from API response
             * @returns {ForecastResult} Complete forecast result with service name
             */
            const transformWttrinData = (validationResult) => {
                if ('error' in validationResult) {
                    return {
                        serviceName: name,
                        error: validationResult.error
                    };
                }
                
                const weather = validationResult.data;
                const avgTempC = parseFloat(weather.avgtempC || weather.maxtempC || 0);
                const maxWindSpeedKmph = parseFloat(weather.hourly?.[0]?.windspeedKmph || 0);
                const precipMM = parseFloat(weather.hourly?.[0]?.precipMM || 0);
                const humidity = parseFloat(weather.hourly?.[0]?.humidity || 0);
                const description = weather.hourly?.[0]?.weatherDesc?.[0]?.value || 'Unknown';
                
                return {
                    serviceName: name,
                    data: {
                        temperature: TemperatureUtils.roundToDecimal(avgTempC),
                        temperatureFahrenheit: TemperatureUtils.roundToDecimal(TemperatureUtils.celsiusToFahrenheit(avgTempC)),
                        description: description,
                        humidity: TemperatureUtils.roundToDecimal(humidity),
                        windSpeed: TemperatureUtils.roundToDecimal(maxWindSpeedKmph),
                        precipitation: TemperatureUtils.roundToDecimal(precipMM),
                        icon: getWeatherIcon(description)
                    }
                };
            };

            return {
                name,
                /**
                 * Fetches forecast from wttr.in API
                 * @param {ForecastRequest} request - Forecast request parameters
                 * @returns {Promise<ForecastResult>} Forecast result
                 */
                fetchForecast: async ({ date, coordinates: { latitude, longitude } }) => {
                    const url = buildApiUrl(latitude, longitude, date);
                    const jsonResult = await fetchAndParseJson(url);
                    const validationResult = validateResponseData(jsonResult);
                    return transformWttrinData(validationResult);
                }
            };
        };

        // ========================================
        // Business Logic - Forecast Aggregator
        // ========================================

        /**
         * Creates a weather service object with multiple forecast providers
         * @param {Array<WeatherProvider>} providers - Array of weather providers
         * @returns {WeatherService} Weather service object with forecast method
         */
        const createWeatherService = (providers) => {
            return {
                /**
                 * Fetches forecasts from all providers
                 * @param {ForecastRequest} request - Forecast request parameters
                 * @returns {Promise<Array<ForecastResult>>} Array of forecast results from all providers
                 */
                forecast: async (request) => {
                    const promises = providers.map(provider => provider.fetchForecast(request));
                    return await Promise.all(promises);
                }
            };
        };

        // ========================================
        // View Layer - DOM Manipulation
        // ========================================

        /**
         * Creates a status message object with show/hide methods
         * @param {HTMLElement} element - Status message element
         * @returns {StatusMessage} Status message object with methods
         */
        const createStatusMessage = (element) => {
            return {
                /**
                 * Shows status message
                 * @param {string} message - Message to display
                 * @param {'loading'|'error'} type - Message type
                 * @returns {void}
                 */
                show: (message, type) => {
                    element.textContent = message;
                    element.classList.remove('status--hidden', 'status--loading', 'status--error');
                    element.classList.add('status', `status--${type}`);
                },
                /**
                 * Hides status message
                 * @returns {void}
                 */
                hide: () => {
                    element.classList.remove('status--loading', 'status--error');
                    element.classList.add('status--hidden');
                }
            };
        };


        /**
         * Creates an HTML element from a template string
         * @param {string} template - HTML template string
         * @returns {HTMLElement} Created element
         */
        const createElement = (template) => {
            const container = document.createElement('template');
            container.innerHTML = template.trim();
            return container.content.firstElementChild;
        };

        /**
         * Creates weather card success element
         * @param {{serviceName: string, data: WeatherData}} result - Forecast result with data
         * @returns {HTMLElement} Weather card element
         */
        const createWeatherCardSuccessTemplate = ({ 
            serviceName, 
            data: { temperature, temperatureFahrenheit, description, icon, windSpeed, precipitation, humidity } 
        }) => {
            return createElement(`
                <article class="weather-card">
                    <header class="weather-card__header">
                        <h3 class="weather-card__service">${serviceName}</h3>
                        <span class="weather-card__status">Active</span>
                    </header>
                    <div class="weather-card__main">
                        <div class="weather-card__temperature">${temperature}Â°C</div>
                        <div class="weather-card__condition">
                            <div class="weather-card__description">${description}</div>
                            <div class="weather-card__icon">${icon}</div>
                        </div>
                    </div>
                    <div class="weather-card__details">
                        <div class="weather-card__detail">
                            <span class="weather-card__detail-label">Fahrenheit</span>
                            <span class="weather-card__detail-value">${temperatureFahrenheit}Â°F</span>
                        </div>
                        <div class="weather-card__detail">
                            <span class="weather-card__detail-label">Wind Speed</span>
                            <span class="weather-card__detail-value">${windSpeed} km/h</span>
                        </div>
                        <div class="weather-card__detail">
                            <span class="weather-card__detail-label">Precipitation</span>
                            <span class="weather-card__detail-value">${precipitation} mm</span>
                        </div>
                        <div class="weather-card__detail">
                            <span class="weather-card__detail-label">Humidity</span>
                            <span class="weather-card__detail-value">${humidity > 0 ? humidity + '%' : 'N/A'}</span>
                        </div>
                    </div>
                </article>
            `);
        };

        /**
         * Creates weather card error element
         * @param {{serviceName: string, error: string}} result - Forecast result with error
         * @returns {HTMLElement} Weather card element
         */
        const createWeatherCardErrorTemplate = ({ serviceName, error }) => {
            return createElement(`
                <article class="weather-card">
                    <header class="weather-card__header">
                        <h3 class="weather-card__service">${serviceName}</h3>
                        <span class="weather-card__status">Error</span>
                    </header>
                    <p style="opacity: 0.8; margin-top: 1rem;">Error: ${error}</p>
                </article>
            `);
        };


        // ========================================
        // Application Controller
        // ========================================

        /**
         * Creates a forecast form component
         * @param {HTMLFormElement} formElement - Form DOM element
         * @param {HTMLInputElement} dateInput - Date input element
         * @param {HTMLInputElement} cityInput - City input element
         * @param {HTMLButtonElement} buttonElement - Submit button element
         * @param {GeocodingService} geocodingService - Geocoding service instance
         * @returns {ForecastFormComponent} Forecast form component
         */
        const createForecastFormComponent = (formElement, dateInput, cityInput, buttonElement, geocodingService) => {

            /**
             * Validates form values
             * @returns {{} | {error: string}} Validation result
             */
            const validate = () => {
                const date = dateInput.value;
                const city = cityInput.value.trim();

                if (!date || !/^\d{4}-\d{2}-\d{2}$/.test(date)) {
                    return { error: 'Invalid date format. Use YYYY-MM-DD.' };
                }

                if (!city || city === '') {
                    return { error: 'City name cannot be empty.' };
                }

                return {};
            };

            return {
                /**
                 * Creates and validates forecast request (async for geocoding)
                 * @returns {Promise<ForecastRequestResult>} Request result with data or error
                 */
                createRequest: async () => {
                    const validation = validate();
                    if ('error' in validation) {
                        return { error: validation.error };
                    }

                    // Geocode the city name to get coordinates
                    const geocodeResult = await geocodingService.geocode(cityInput.value);
                    
                    if ('error' in geocodeResult) {
                        return { error: geocodeResult.error };
                    }

                    const { latitude, longitude, displayName } = geocodeResult.data;

                    return {
                        data: {
                            date: dateInput.value,
                            coordinates: {
                                latitude,
                                longitude
                            },
                            displayName
                        }
                    };
                },
                /**
                 * Sets default form values
                 * @returns {void}
                 */
                setDefaultValues: () => {
                    const today = new Date().toISOString().split('T')[0];
                    dateInput.value = today;

                    cityInput.value = CONFIG.DEFAULT_LOCATION.city;
                },
                /**
                 * Disables form submission
                 * @returns {void}
                 */
                disable: () => {
                    buttonElement.disabled = true;
                },
                /**
                 * Enables form submission
                 * @returns {void}
                 */
                enable: () => {
                    buttonElement.disabled = false;
                },
                /**
                 * Registers form submit handler
                 * @param {() => Promise<void>} callback - Async callback to execute on form submit
                 * @returns {void}
                 */
                onSubmit: (callback) => {
                    const handleSubmit = async (event) => {
                        event.preventDefault();
                        await callback();
                    };

                    formElement.addEventListener('submit', handleSubmit);
                }
            };
        };

        /**
         * Creates a forecast result component
         * @param {HTMLElement} sectionElement - Forecast section element
         * @param {HTMLElement} locationElement - Location display element
         * @param {HTMLElement} dateElement - Date display element
         * @param {HTMLElement} servicesContainer - Services container element
         * @returns {ForecastResultComponent} Forecast result component
         */
        const createForecastResultComponent = (sectionElement, locationElement, dateElement, servicesContainer) => {
            /**
             * Formats date string to long locale format
             * @param {string} date - ISO date string (YYYY-MM-DD)
             * @returns {string} Formatted date string
             */
            const formatDate = (date) => {
                return new Date(date).toLocaleDateString('en-US', {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
            };

            return {
                /**
                 * Shows forecast section
                 * @returns {void}
                 */
                show: () => {
                    sectionElement.classList.remove('forecast--hidden');
                },
                /**
                 * Hides forecast section
                 * @returns {void}
                 */
                hide: () => {
                    sectionElement.classList.add('forecast--hidden');
                },
                /**
                 * Displays forecast location and date
                 * @param {ForecastRequest} request - Forecast request with coordinates and date
                 * @returns {void}
                 */
                displayInfo: ({ coordinates, date, displayName }) => {
                    const locationText = displayName || CoordinateUtils.format(coordinates);
                    locationElement.textContent = locationText;
                    dateElement.textContent = formatDate(date);
                },
                /**
                 * Displays weather results
                 * @param {Array<ForecastResult>} results - Array of forecast results to display
                 * @returns {void}
                 */
                displayResults: (results) => {
                    const cardElements = results.map(result => 
                        'error' in result
                            ? createWeatherCardErrorTemplate(result)
                            : createWeatherCardSuccessTemplate(result)
                    );
                    
                    servicesContainer.replaceChildren(...cardElements);
                }
            };
        };

        /**
         * Creates application state object with UI components
         * @param {AppStateComponents} components - UI components including weather service
         * @returns {AppState} Application state object
         */
        const createAppState = (components) => {
            /**
             * Validates and creates forecast request (async for geocoding)
             * @returns {Promise<ForecastRequest|null>} Request data or null if validation fails
             */
            const validateRequest = async () => {
                const { forecastForm, statusMessage } = components;
                const result = await forecastForm.createRequest();
                if ('error' in result) {
                    statusMessage.show(result.error, 'error');
                    return null;
                }
                return result.data;
            };

            /**
             * Shows loading state
             * @returns {void}
             */
            const showLoadingState = () => {
                const { forecastForm, statusMessage, forecastResult } = components;
                forecastForm.disable();
                statusMessage.show('Fetching forecast data...', 'loading');
                forecastResult.hide();
            };

            /**
             * Fetches forecast from weather service
             * @param {ForecastRequest} request - Forecast request parameters
             * @returns {Promise<Array<ForecastResult>|null>} Forecast results or null if error
             */
            const fetchForecast = async (request) => {
                const { weatherService, statusMessage, forecastForm } = components;
                try {
                    return await weatherService.forecast(request);
                } catch (error) {
                    statusMessage.show(`Failed to fetch forecast: ${error.message}`, 'error');
                    return null;
                } finally {
                    forecastForm.enable();
                }
            };

            /**
             * Displays forecast results
             * @param {ForecastRequest} request - Forecast request parameters
             * @param {Array<ForecastResult>} results - Forecast results to display
             * @returns {void}
             */
            const displayForecast = (request, results) => {
                const { statusMessage, forecastResult } = components;
                statusMessage.hide();
                forecastResult.displayInfo(request);
                forecastResult.displayResults(results);
                forecastResult.show();
            };

            return {
                /**
                 * Sets default values for all components
                 * @returns {void}
                 */
                setDefaultValues: () => {
                    const { forecastForm } = components;
                    forecastForm.setDefaultValues();
                },
                /**
                 * Initializes the application
                 * @returns {void}
                 */
                initialize: function() {
                    const { forecastForm } = components;
                    forecastForm.onSubmit(this.update);
                },
                /**
                 * Updates forecast with registered weather service
                 * @returns {Promise<void>}
                 */
                update: async () => {
                    const request = await validateRequest();
                    if (!request) return;

                    showLoadingState();
                    
                    const results = await fetchForecast(request);
                    if (results) {
                        displayForecast(request, results);
                    }
                }
            };
        };

        /**
         * Initializes the weather forecast application
         * @returns {void}
         */
        const initializeApp = () => {
            const geocodingService = createGeocodingService();

            const forecastForm = createForecastFormComponent(
                document.getElementById('forecastForm'),
                document.getElementById('dateInput'),
                document.getElementById('cityInput'),
                document.getElementById('submitButton'),
                geocodingService
            );

            const statusMessage = createStatusMessage(document.getElementById('statusMessage'));

            const forecastResult = createForecastResultComponent(
                document.getElementById('forecastResults'),
                document.getElementById('forecastLocation'),
                document.getElementById('forecastDate'),
                document.getElementById('forecastServices')
            );

            const weatherService = createWeatherService([
                createOpenMeteoService(),
                createWttrinService()
            ]);

            const appState = createAppState({
                forecastForm,
                statusMessage,
                forecastResult,
                weatherService
            });

            appState.setDefaultValues();
            appState.initialize();
        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }
    </script>
</body>
</html>
